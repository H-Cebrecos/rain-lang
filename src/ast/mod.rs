use std::{
    fmt::{self},
    ops::Range, str,
};

use crate::printer::indent;

pub struct Module<'a> {
    pub name : &'a str,
    pub spec :Spec<'a>,
    pub declarations : (),
    pub rtl  : (), //TODO:
}

#[derive(Debug)]
pub struct Spec<'a> {
    pub name: &'a str,
    pub generics: Option<Vec<Generic<'a>>>,
    pub io: Vec<Signal<'a>>,
}

#[derive(Debug, Clone)]
pub struct Generic<'a> {
    pub name: &'a str,
    pub typ: &'a str,
    pub default: Option<usize>,
}
impl fmt::Display for Generic<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "\t{}\t: {}", self.name, self.typ)?;

        if let Some(def) = self.default {
            write!(f, " := {}", def)?;
        }

        Ok(())
    }
}

#[derive(Debug, Default, Clone, PartialEq)]
pub enum Direction {
    #[default]
    In,
    Out,
    InOut,
}
impl fmt::Display for Direction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            Direction::In => "In ",
            Direction::Out => "Out",
            Direction::InOut => "InOut",
        };
        write!(f, "{}", s)
    }
}

#[derive(Debug)]
pub struct Signal<'a> {
pub    name: &'a str,
pub    sig_typ: SignalType,
pub    mode: SignalMode,
pub    typ : Type
}

#[derive(Debug)]
pub enum SignalType {
    Interface(Direction),
    Internal,
}
impl fmt::Display for SignalType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Self::Interface(s) = self{
            write!(f, "{}", s)
        } else {
            write!(f, "")
        }
    }
}
#[derive(Debug)]
pub enum Type {
    Logic {
        range: Range<usize>,
    },
}

#[derive(Debug, PartialEq, Clone)]
pub enum SignalMode{
    Sync,
    Comb,
}

#[derive(PartialEq)]
pub enum DecZone {
    Spec,
    Impl,
}

impl fmt::Display for Type {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            Type::Logic { range } => {
                if range.end == 0 && range.start == 0 {
                    "std_logic"
                } else {
                    &format!("std_logic_vector({} downto {})", range.end, range.start)
                }
            }

            //Type::Clock => "logic",
            //Type::Integer => "integer",
        };
        write!(f, "{}", s)
    }
}

impl fmt::Display for Signal<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "\t{}\t: {} {}", self.name, self.sig_typ, self.typ)
    }
}





pub struct AsyncSync<'a> {
    pub id: &'a str,
    pub active_low: bool,
    pub falling_edge: bool,
    pub stages: usize,
    pub sig_in: &'a  Signal<'a>,
    pub sig_out: &'a Signal<'a>,
    pub clk: (), //TODO: implement clk representation, probably include the edge stuff inside. this represent clock domains.
}
impl AsyncSync<'_> {
    //WARNING: MISSING SIGNAL DECLARATION.
    pub fn generate_declarations(&self) -> () {
        ()
    }
    pub fn generate_rtl(&self) -> Vec<String> {
        let level = if self.active_low { '0' } else { '1' };
        let n_level = if !self.active_low { '0' } else { '1' };

        let edge = if self.falling_edge {
            "falling_edge"
        } else {
            "rising_edge"
        };

        let mut lines = Vec::new();

        lines.push("-- Autogenerated asynchronously asserted, synchronously deasserted signal synchronizer.".to_string());

        lines.push(format!("process ({{clk}}, {})", self.sig_in.name));
        lines.push("begin".to_string());

        let mut proc = Vec::new();
        proc.push(format!("if {} = '{level}' then", self.sig_in.name));

        let if_sec = format!("{0}_sync_stages <= (others => '{level}');", self.id);
        proc.append(&mut indent(&[if_sec], 1));

        proc.push(format!("elsif {edge}({{{{clk}}}}) then",));

        let mut elsif = Vec::new();
        elsif.push(format!("{}_sync_stages(1) <= '{n_level}';", self.id));
        elsif.push(format!("for i in 2 to {}_STAGES loop", self.id));

        let for_sec = format!("{0}_sync_stages(i) <= {0}_sync_stages(i-1);", self.id);
        elsif.append(&mut indent(&[for_sec], 1));

        elsif.push("end loop;".to_string());
        proc.append(&mut indent(&elsif, 1));
        proc.push("end if;".to_string());

        lines.append(&mut indent(&proc, 1));

        lines.push("end process;\n".to_string());

        lines.push(format!("{1} <= {0}_sync_stages({0}_STAGES)", self.id, self.sig_out.name));

        lines.push("\n-- ASYNC_REG attribute on each flip-flop".to_string());

        lines.push(format!("for i in 1 to {0}_STAGES generate", self.id));

        let mut async_attr = Vec::new();
        async_attr.push("attribute ASYNC_REG : string;".to_string());
        async_attr.push(format!(
            "attribute ASYNC_REG of {0}_sync_stages(i) : signal is \"TRUE\";",
            self.id
        ));

        lines.append(&mut indent(&async_attr, 1));
        lines.push("end generate;".to_string());

        lines.push("-- End of Sync-Async synchronizer.".to_string());

        lines
    }
}
